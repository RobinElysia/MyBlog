---

title: 浅谈计算机设计哲学—“贯穿计算机硬件、操作系统与程序的万能状态机”
description: 我对状态机与计算机的理解
date: 2025-06-22
timeline: true
head:
  - - meta
    - name: keywords
      content: 从硬件、固件、操作系统、程序的视角来介绍今天的主角——状态机 | RobinElysia | qwp
  - - meta
    - name: description
      content: 从硬件、固件、操作系统、程序的视角来介绍今天的主角——状态机
  - - meta
    - name: author
      content: RobinElysia
category:
  - RobinElysia
tag:
  - 计算机
  - 原理
  - RobinElysia
---

<link rel="stylesheet" href="../.vuepress/css/font-style.css">

# 浅谈计算机设计哲学—“贯穿计算机硬件、操作系统与程序的万能状态机”

## 前言
&emsp;这篇文章几乎浓缩了作者本人学计算机的几个重要知识体系，包括 ***计算机组成原理、计算机操作系统、Java/Python高级编程与多任务、分布式系统*** 等，可以说来了个知识大杂烩，而且大部分内容我也没有在之前的工作室说过，因为知识面太广了，直接拿出来说可能会出现大面积听不懂的情况。但是为什么我还要写这篇文章？因为我的计算机知识体系串联了，一些根本性的问题我得到了本质的解决，所以我才能写这篇文章。\
&emsp;之后我要感谢来自 ***南京大学计算机研究所的*** [jyy](https://jyywiki.cn/)***副教授***。在听他的计算机操作系统课的时候，所提出的观点<font color= #ff6164>***“Everything is a state machine”***</font>***(万物皆是状态机)***。也就是我写这篇文章灵感来源，我们今天所要聊的主角——***状态机***

## 什么是状态机
&emsp;各位如果认真看了我的[AboutMe](../AboutMe.md)，就已经知道了大概了解了什么是状态机，如果你懒得过去看也没关系，我可以再解释一遍。\
&emsp;我们生活当中有很多常见的状态机，比如说存钱罐，你可以把这个存钱罐比作我们现在的机器。存钱罐的初始值是 *num = 0*，假如我们现在有钱，并尝试存入面值为 *n* 的钱时，存钱罐会执行 *K1* 这个 *num += n* 的操作。你会发现在某一个特定的时刻 *Ti*，这个存钱罐的钱是确定的，并且这个存钱罐执行操作可以是 *+=、Reset*，由此我们就引出了这个概念——状态机\
&emsp;在上述例子中，我们可以知道存在这个几个关键，即：

OldState（旧状态）、Event（条件）、Transition（转换）、Action（新状态）\
它们分别对应着：\
*num = 0（旧状态）*、*我有 n 钱（条件）*、*+=（转换）*、*num += n（新状态）*

&emsp;到此你就明白了，什么是状态机。也就是说状态机就是顾名思义，它有状态、有状态的迁移。所以我们就可以给它下一个严格数学定义：

&emsp;***状态机（State Machine）*** 是一个抽象的 ***数学模型***，用于 ***描述系统在离散状态间的行为逻辑***，其核心特征是：\
&emsp;<font color= #ff6164>系统在任何时刻仅处于一个确定的状态（State），并根据输入事件（Event）按照预定义的转换规则（Transition）切换到新状态，同时可能产生新的动作（Action）。</font>

~~***这就是状态机！！！***~~

## 从硬件的角度来看
### Reset与数据迁移
&emsp;首先我们需要达成一定的共识，就是计算机硬件在某种程度上是不知道有上层应用的，也就是它感知不到操作系统和程序，只是一个无情的提供各种服务（~~一个无情的执行机器~~）。我们之所以强调这一点的原因是，在早期的计算机中，是不存在所谓的“操作系统”的，并且当时的硬件性能很差，一动不动就死机，这也就是我们将常在老一代的电脑上看到 *Reset* 按钮的原因...诶？*Reset*？这个按钮仅仅只有这个功能么？你会发现这个过程：电脑开机——电脑执行——死机——复位。这个过程似乎和状态机本身有着一定的相似性。没错计算机硬件在某种程度上就是 ***实体的状态机***

&emsp;我们来看最简单的结构，以固态硬盘的一个小浮栅晶体管举例：
<img src="/assets/img/StateMachine/fushanjingtiguan.jpg" style="zoom:50%;display: block;
margin: 0 auto;" />

&emsp;每一个浮栅晶体管在特定时刻仅可存储特定的 *0 or 1*，在某种程度上讲，浮栅晶体管就是天然的~~物理可见~~的状态机，也就是01迁移改变。这部分的知识你可以参考[B站硬件茶谈的固态硬盘原理](https://www.bilibili.com/video/BV1aF411u7Ct/?spm_id_from=333.337.search-card.all.click)。这是在存储上，实际上在内存、CPU寄存器中也是同样的，状态迁移就是把一个数据改掉或者删除。
```C
// 寄存器、内存
struct CPUState {
    uint32_t regs[32], csrs[CSR_COUNT];
    uint8_t *mem;
    uint32_t mem_offset, mem_size;
};
```
### CPU Reset
除此以外，我们也可以知道CPU Reset其实也是一种可以将状态机复位到初始状态的操作。而这个复位流程大致是：
1. 复位信号产生
2. 硬件复位：寄存器（通用寄存器、控制寄存器、段寄存器）、缓存（CPU的一二三级缓存）等
3. 第一条指令执行：JMP、访问固件地址 *0xFFFFFFF0*
3. 固件初始化加载
4. 操作系统内核加载
5. 操作系统加载

~~相当于给 CPU *再开一次机*~~

所以综上所述，我会直接告诉各位。***计算机硬件，就是一种状态机***

## 从固件的角度来看
### 什么是固件与软盘
&emsp;但是我们好像又发现了什么新东西...？固件是个啥？<font color= #ff6164>*firmware*</font>？没错，也就是各位比较清楚的，每次手机更新系统都会通知你的 ***“你的手机可以升级固件”*** 了，你会发现实际上我们在实际使用计算机设备的时候 ***很少感知到固件的存在***，为什么？其实原因很简单，在上述的复位介绍中，我们可以清晰地看到固件作用在 *“硬件——操作系统”* 之间。这时候懂得人会说：“BIOS？”。是的，就是BIOS，不过准确说BIOS是固件的一种，只不过现在大部分人只知道BIOS，不知道固件。那我们也可以讲一些有意思的故事来说说 ***“什么是固件”***\
&emsp;早期我们计算机的存储实际上并没有什么机械硬盘、固态硬盘这些。相反它们更多的是使用软盘（~~不会真的有人以为我不知道软盘吧？实际上有的也不软~~），这些软盘在设计的时候会专门留出来512字节（~~大概？~~），用来存储引导固件。在某种层面上讲，这是一个不错的设计，方便计算机BIOS可以在512字节的最后识别 *0x55* 和 *0xaa*并确认，哦，这是一个软盘。（*0xaa55*，一般叫它引导扇区签名*Boot Signature*或者魔数*Magic Number*？（~~很奇特的数都可以叫魔数，你说对吧快速平方根倒数运算~~））
```C
// 访问0xaa55
unsigned short *ptr = (unsigned short *)0xaa55;
unsigned short value = *ptr;

// 或者shell
(printf "\xeb\xfe"; cat /dev/zero | head -c 508; printf "\x55\xaa") > a.img
// 2进制查看 a.img
// 你就会看到 0xaa55
```

<img src="/assets/img/StateMachine/0xaa55.png" style="zoom:25%;display: block;
margin: 0 auto;" />

&emsp;但是我说过，在某种程度上讲...所以可能会出现一种情况是，有人恶意篡改这个扇区的数据，写入恶意代码。这也就不得不提另一个有意思的事了。CIH病毒，一个可以篡改BIOS固件，导致电脑硬件出现问题无法开机的病毒（作者是台湾大学的陈盈豪），这也导致了后来的固件要么只读，要么加入各种认证和数字鉴证，避免恶意或者错误修改（~~世界就是一个巨大的草台班子~~）。也就是为什么固件很少被感知的原因，因为需要考虑安全问题...\
&emsp;但是说了这么多，我们还是没清晰的认识固件这个东西，它到底是什么？在早期的计算机硬件中，我们的固件都是和ROM绑定的（中~~CIH病毒可以直接换ROM了~~），想升级固件就只能换ROM，也就是说“结合上述我们可以破坏特定硬件当中的数据”，固件实际上也是一段程序。<font color= #ff6164>***它主要负责的是运行程序前的计算机系统配置，只不过这些程序有可能是操作系统（BIOS）？***</font>后者其实不严格的说法，因为你可以在各大手机刷机论坛中发现，绕过固件检测实现刷机的~~骚操作~~（[~~小米6刷澎湃OS，@雷军~~](https://www.bilibili.com/video/av364983952/?vd_source=dca5deabbb49f895ff5ec660b9e33dd4)）。所以更严格一点是可能引导加载程序...\
&emsp;<font color= #fdeff2>***然后我们就发现了新问题：固件是程序？那程序是什么？***</font>

## 从程序的角度来看
### 什么是程序、初识系统调用
&emsp;我们兜兜转转最后还是来到了我们比较熟悉的程序，我们需要清楚程序是什么，才能回去解答固件是什么，但是话又说回来，程序本身就属于一个十分难搞得东西（~~参考各位写代码的痛苦经历~~）。So，what's a Program？这句话目前只能交给我来回答（~~因为只有我在写这个稿子~~\
&emsp;但是我确实应该站在各位的角度，才可以让各位更好的理解我接下来说的话。你们在初学计算机程序设计（编程）的时候肯定会有疑问：“啥是编程？为什么单单一个处理各种运算的代码，就能写出来各种大型程序？程序到底是什么？为什么我写的代码会存在报错？”等等问题。但是没关系，接下来的话我将一点一点告诉各位为什么。\
&emsp;首先我需要告诉大家的是：<font color= #ff6164 size=4>***程序 = 数据 + 处理 + 控制结构 + 系统调用（systemcall）***</font>，你会发现前三者在大家所学的 ***编程*** 中都有所体现，也就是各种<font color= #fdeff2>*数据类型、运算和处理以及三大结构语句*</font>（系统调用又是个什么？不急，这个在后边操作系统角度会详细说明，只需要清楚我们的编程语言在实现上 ***原生支持前三者***）。我们会发现实际上我们现在所学的编程，大部分都作用在前三者，你们有广泛的涉及 ***系统调用*** 么？有！但不多！大家是否还记得 *文件操作：read and write* 么？也就是对文件的读写。没错，这两个函数底层就是一个系统调用。也就是说很大程度上我们只知道，哦，这是一个函数，一个编程语言提供的工具，我们知道如何使用。但是实际上呢？<font color= #deb068>实际上是编程语言本身不具备这样的能力，去把 一数据写入磁盘当中，而是通过 ***操作系统*** 提供的 ***工具（API）*** 来实现的。</font>这也是为什么？我们目前写的程序没有我们想象的那么 *厉害*，因为我们没有深入到系统调用。

```Bash
// 查看Linux系统调用手册
man syscall
```

[Linux syscall帮助文件](/file/syscall.txt)

### 程序到底是什么？
&emsp;以上我们就知道了什么是程序。为什么我们学完编程还是没能写出 ***大型软件*** 的原因。但是如果是我，我还会继续追问：<font color=#deb068>“程序仅仅只是这样的等式么？貌似这样子只看到了程序是由什么组成的，程序的本质到底是什么？为什么存在编译型和解释型这样的语言类别？为什么我们要有Debug？程序与Debug之间有什么关系么？为什么会报错？”</font>等等一系列问题...关于这些问题，答案是必然唯一的，它们都和今天的状态机有关！\
&emsp;<font color= #ff6164>程序的本质是状态机的 ***静态描述***</font>。你可以在Debug的过程中发现，每一行代码的执行，每一个变量、常量、函数方法的执行，都是状态的改变。在C语言中，我们可以使用gdb进行编译调试，断点、跳入和跳出等操作。我们可以看到 ***每一门语言，无论编译型还是解释型，它们都可以进行调试，也就是说我们按照一行一行代码执行的话，两种类型是无异的***，甚至你可以给Python写一个编译器，给Java写一个解释器。（[Java](https://blog.51cto.com/u_14224/11900050)、[Python](https://www.cnblogs.com/delishcomcn/p/17716411.html)）但这都毫无意义，无论是编译还是解释，无非影响的是语言本身，我们关注的更多在实现。但在关注实现的时候，还是避免不了程序的 *Bug*。*Bug* 是令人讨厌的，我们需要规避它，但是怎么规避是一个问题...\
&emsp;在状态机那里，我们知道了状态是唯一确定的，也就是按照这一特性，我们完全可以类比到程序设计上。代码在某一时刻是否存在bug，取决于该状态是否*出乎意料*。我们希望的是，每一个状态我们都清楚，并且前后关系明确。那有没有可能我们可以使用一种形式来表示出一个程序的所有的状态呢？[Hello算法](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion/)这个网站给了我答案，你可以在它的代码运行块下看到每一步运行的状态。也就是状态机的每一个状态！\
&emsp;现在我们清楚了，哦，原来程序是状态机的 ***静态描述***，那我是否可以举几个例子来验证我的想法呢？我想最好的例子就是那个当年令所有初学者头疼的 ***汉诺塔***，但这不是重点，我想既然程序是一个状态机，那我们就可以以状态机的方式来写一个 ***非递归的汉诺塔***。（~~是的，更难了~~）我不会写，没关系我可以AI：

```Bash
// prompt：根据状态机的原理，实现一个C语言非递归汉诺塔
```

[非迭代汉诺塔代码：hanoi.c](/file/hanoi.c)

<img src="/assets/img/StateMachine/StateChange.png" style="zoom:25%;display: block;
margin: 0 auto;" alt="每一个时刻，进程都有一个状态" />

&emsp;好的，我们可以看到AI的这段代码写的还是不错的，在栈中存放状态对象（State）也是我们所想的那样，通过取出栈中的操作进而实现非递归效果，也就进而印证了我们的猜想：***程序是状态机的静态描述***...等等，我们是不是漏了什么？***静态描述*** 又是什么？程序不是状态机么？怎么多了个 ***静态描述*** ？为了解答这个问题，我想我是时候引入计算机操作系统了。

## 从操作系统的角度来看

### 前言
&emsp;在前面各位已经知道了，计算机硬件是状态机、固件是程序，而程序又是状态机的 ***静态描述***，那我们就可以大胆猜一下，操作系统也是状态机？先说结论吧，这句话不完全对。正确的答案应该是：<font color=#ff6164>***操作系统即是状态机，同样也是状态机的管理者！***</font> \
&emsp;我知道看到这里，估计各位已经晕头转向了，什么 ***静态描述*** ？什么 ***状态机管理者*** ？这都什么跟什么...没关系，我们一个一个来解释。\
&emsp;我们在[程序角度](http://elysia.wiki/posts/浅谈计算机设计哲学—“贯穿计算机硬件、操作系统与程序的万能状态机”.html#从程序的角度来看)的时候，提到了 *系统调用* 这个词，我没有去解释，这里需要回过头说一下。事实上，<font color=#deb068>**系统调用是计算机操作系统为上层程序提供的API接口（Application Programming Interface，可以理解为操作系统提供的一系列工具），而这些工具，基本上和硬件又扯上关系，也就是操作系统封装计算机硬件。** </font>\
&emsp;之后我们又提到<font color=#ff6164>***程序的本质是状态机的静态描述***</font>，这句话中的静态描述又是什么意思？难不成还有动态？答案是：是的。并且这个 ***动态描述的*** 状态机我们还可以在系统中实打实的看见，没错它就是：<font color=#ff6164> ***进程（Process）*** </font>

### 进程与获取进程状态
&emsp;当我们双击打开一个文件，我们就创建了一个程序的实例，一个进程、一个状态机。<font color=#deb068>程序代码代表了它所对应的状态机内在逻辑，而进程（Process）则是这段代码实际的运行效果，你可以看到这个进程状态机在某一时刻的某个状态！</font>

<img src="/assets/img/StateMachine/ProcessAndApplication.png" style="zoom:25%;display: block;
margin: 0 auto;" alt="每一个时刻，进程都有一个状态" />

&emsp;之后我们就会想，既然是 *进程（Process）*，它就会存在 <font color=#ff6164>***PID（Process ID）*** 和 ***PPID（Parent Process ID）*** </font>，它们在操作系统中是怎么来的？怎么创建？怎么销毁？等等等等...\
&emsp;不过解决这些问题之前，先让我们回到最开始的另一个问题：<font color=#ff6164>***为什么说操作系统即是状态机，又是状态机的管理者？***</font>这句话实际上讲到这里已经有答案了，***我们说系统当中的进程是状态机，而且操作系统本身也是状态机，操作系统可以管理进程，进而我们说，<font color=#deb068>操作系统是管理状态机的状态机。</font>*** 之后我们再回过头去，操作系统当中到底是怎么管理这些进程的？\
&emsp;首先，<font color=#deb068>每一个进程都会有一个PID，这个PID是逐步递增的。PID来自操作系统内核、存储在操作系统的内核空间中，而不是存储在程序的寄存器或用户态内存中。也就是需要syscall获取它</font>：

<img src="/assets/img/StateMachine/SystemAndProcess.png" style="zoom:25%;display: block;
margin: 0 auto;" alt="System And Process" />
&emsp;获取PID和PPID：
<img src="/assets/img/StateMachine/ps.png" style="zoom:50%;display: block;
margin: 0 auto;" alt="Get PID" />
&emsp;当然，你也可以查看命令帮助（syscall）：\
&emsp;[man getpid](/file/getpid.txt) | [man getppid](/file/getppid.txt) | [man proc](/file/proc.txt)

&emsp;你可以看到在 *proc* 帮助文档的最后，贴心的列出了相关命令（
```bash
SEE ALSO
       cat(1),  dmesg(1),  find(1),  free(1), htop(1), init(1), ps(1), pstree(1), tr(1), uptime(1), chroot(2), mmap(2),
       readlink(2), syslog(2), slabinfo(5), sysfs(5), hier(7), namespaces(7), time(7), arp(8), hdparm(8),  ifconfig(8),
       lsmod(8), lspci(8), mount(8), netstat(8), procinfo(8), route(8), sysctl(8)
```

### 进程的创建与停止
&emsp;上述命令和系统调用你可以一个一个查看，当然你也可以问问AI，这些命令是干嘛的。但总之进程这个状态机，是可以被操作系统 ***调用查看*** 的。但是创建和删除呢？我们知道操作系统中，可以打开执行一个文件，那就必然涉及创建进程（状态机）。没错我接下来就会引入两个方法：
```bash
// 进程内容我不会再过多介绍，但是仍有疑问，我这里列举出来，各位可以直接看：
Q：为什么进程号pid是逐渐递增？会重用？
A：避免冲突；Linux老版范围是1-32767，新版是2^22，64位可能会更高，会设置一个时间间隔进行重用，减少开销
```
<font color=#006e54>

&emsp;**1.** 生成/复制进程（状态机）：CreateProcess/fork\
&emsp;**2.** 停止/复位进程（状态机）：TerminateProcess/_exit/execve
</font>

&emsp;首先我们来说进程的创建，需要说明的是，***Linux*** 和 ***Windows*** 的进程操作非常不一样，上述给出的函数就可以体现。我们先来说说 ***Windows***，十分的浅显易懂，就是创建进程 ***CreateProcess***，~~感觉懂点英语就能看懂~~，我们直接看 ***CreateProcess*** 函数内部：
```C++
// windows没办法直接看内核（
// 微软特有的匈牙利命名法（
BOOL CreateProcess(
  LPCWSTR               lpApplicationName,//指向可执行模块名称的指针
  LPWSTR                lpCommandLine,//指向命令行字符串的指针。
  LPSECURITY_ATTRIBUTES lpProcessAttributes,//指向 SECURITY_ATTRIBUTES 结构的指针，指定新进程的安全属性。
  LPSECURITY_ATTRIBUTES lpThreadAttributes,//指向 SECURITY_ATTRIBUTES 结构的指针，指定新进程的安全属性。
  BOOL                  bInheritHandles,//如果为 TRUE，新进程将继承调用进程的句柄。
  DWORD                 dwCreationFlags,//指定附加的、用来控制优先类和进程的创建的标志。
  LPVOID                lpEnvironment,//指向新进程的环境块的指针。如果为 NULL，新进程将使用调用进程的环境。
  LPCWSTR               lpCurrentDirectory,//指向新进程的当前目录的指针。如果为 NULL，新进程将使用调用进程的当前目录。
  LPSTARTUPINFOW        lpStartupInfo,//指向 STARTUPINFOW 结构的指针，指定新进程的主窗口特性。
  LPPROCESS_INFORMATION lpProcessInformation//指向 PROCESS_INFORMATION 结构的指针，接收新进程的标识符和句柄。
);
```

&emsp;这就是Windows创建进程的系统调用，看不懂没关系，<font color=#deb068>***Windows*** 的创建进程逻辑是符合人类的，就是创建，只不过内部的变量和指针起名方式不太能被人所接受</font>。（不过微软这么做完全是出于软件工程的可维护原则）。之后我们再可以看看 ***TerminateProcess*** 函数：
```C++
BOOL TerminateProcess(
  [in] HANDLE hProcess, // 要终止的进程句柄。
  [in] UINT   uExitCode // 进程和进程将使用的退出代码，由于此调用而终止。
);
```
&emsp;混个眼熟，说实话这段完全没必要记，因为大部分情况下 ***windows*** 内核我们基本不接触，而且即便是接触了，也可以直接问AI或者官方文档（[Create](https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa)、[Terminate](https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess)），我们应该怎么用。或者你懒，但是能直接看懂源码直接调，那也可以。（~~大佬，带带，菜菜~~\
&emsp;但是我们回过头来，我们还不知道操作系统底层到底干了什么？怎么创建的进程？怎么停止的进程？
先来说说 ***Windows*** 操作系统的创建进程大致流程：
<font color=#006e54>

1. 用户层初始化：kernel32.dll内部CreateProcess参数解析，创建内存对象
2. 内核层创建：初始化eprocess（继承父进程、进程ID）、初始化内存地址和存储，挂载到eprocess
3. 进程创建和子系统通知：初始化栈、通知子系统
4. 用户态初始化与执行：从内核态转为用户态，开始执行程序代码
</font>

停止进程：
<font color=#006e54>

1. 用户层触发：程序ExitProcess(uExitCode)
2. 内核层清理：终止进程、卸载DLL、关闭所有相关资源
</font>

&emsp;很正常的逻辑对吧，***创建进程就调用系统，到执行程序代码；删除进程就从用户态转化为内核态执行清除***。诶！我们再来看看 ***Linux***，***Linux*** 就很~~逆天~~巧妙了，它使用的是 ***复制进程*** 的方式创建一个进程。也就是 ***fork()***。这个复制是<font color=#ff6164> ***将父状态机的所有，除了系统级别的所有资源复制一份（PID、打开的文件这些不会复制）*** </font>，很大程度上讲，这不太符合直觉，因为我们知道既然是创建，那就应该从头整一个吧，为什么复制？那 ***Linux*** 是怎么实现得到一个干净的初始化的状态机的？不知道各位是否还记得 *Reset* 这个东西，没错，Linux就是这么~~巧妙~~，它<font color=#ff6164>使用了 *execve* 这个系统调用来 ***复位*** 复制出来的进程状态机，从而达到创建一个初始状态机。</font>那有人会问了：“这不是多此一举么？为什么不直接创建一个新的，而是使用复制？”。各位知道 *“并行运算”* 么？如果知道那就好说了，Linux的这种方式从某种程度上讲确实很多此一举，但是在 ***快节奏、短时间、需要并行运算*** 的时代，这种设计恰恰是好的。

&emsp;那我们就来详细的看看，Linux到底怎么个事。\
&emsp;[man execve](/file/execve.txt) & [man fork](/file/fork.txt)\
&emsp;fork：
```C
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
main(void)
{
   pid_t pid;

   if (signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
      perror("signal");
      exit(EXIT_FAILURE);
   }
   pid = fork(); // 无需传值
   switch (pid) {
   case -1: // 创建失败
      perror("fork");
      exit(EXIT_FAILURE);
   case 0: // 创建成功
      puts("Child exiting.");
      exit(EXIT_SUCCESS);
   default: // 默认执行
      printf("Child is PID %jd\n", (intmax_t) pid);
      puts("Parent exiting.");
      exit(EXIT_SUCCESS);
   }
}
```

&emsp;execve：
```C
#include <unistd.h>
       int execve(const char *pathname, char *const _Nullable argv[],
                  char *const _Nullable envp[]);
```

&emsp;fork没什么可说的，因为它无需传值，返回0或者-1，直接用就可以，但是execve不同，我们需要传入：***可执行文件名, *arg参数,envp环境变量***，其中可执行文件是你在复位状态机后执行的程序。举个例子：你可以在C语言编译的时候看到遍历查找as可执行文件，~~虽然很傻但是很有效~~，如果没找到那就会报错“Not Find File”。其他的这些参数你都可以在上述 man 帮助文档里查看（甚至是样例代码）。之后我们再来说说详细的Linux创建，复位，删除进程的流程：<font color=#8b968d>***先fork，再复位execve(可执行文件名, *arg参数,envp环境变量)，执行libc系统调用，最后传入初始 main(argc,argv,envp)三个参数，最后调用_exit函数删除进程***。</font>

&emsp;这就是我要说的进程相关的内容了，我们证实了操作系统是管理状态机的状态机。那么接下来我们就继续深入进程、状态机和多任务。来为大家揭晓多任务编程的真正本质！
```bash
// 还有一些有趣的问题也是没有时间做详细的解释，这里我放在代码块中

Q：父进程被杀掉后子进程怎么办？（A创建B，B创建C）
A：当进程 B 结束时，进程 C 的父进程会变成操作系统的 init 进程（通常是 PID 1）。
这个过程被称为“reparenting”（重新设置父进程），产生的 C 进程被称为“孤儿进程”。
init 进程发送 SIGCHLD 信号通知新子进程，init 进程通过 wait() 接管 C 的生命周期管理

Q：sysd 和 sysd --user 进程是什么？
A：Linux中的sysd和sysd --user：systemd 系统实例是整个 Linux 系统的服务管理器，
其 PID 为 1，是系统启动时的第一个进程，负责启动和管理系统的主要服务和守护进程。
而 systemd -user 进程是 systemd 系统实例的子进程，专门为特定用户会话管理服务，
也就是本用户级别的孤儿进程。本质两者的核心原理和机制是一样的，只不过作用范围不同。

Q：Linux当中那些有趣的进程：
A：问问AI？

Q：如何清晰的查看所有进程的关系？
A：pstree

Q：什么是fork Bomb？
A：一段指令：:() { :|:& };:
不断的产生新的进程，直到耗光你的系统资源，但是现在有OOM机制做防护

Q：fork执行了两次，状态机总共数量有几个？
fork的两次的同时print打印一行数据，会打印几次？管道符输出呢？
A：4个，状态机的fork是指数级的创建，2^n。6次。8次
6 和 8 不一样的原因是，printf如果和管道符共同使用，那么会存在缓冲区，
缓冲区达到长度再输出，而单独使用则是有啥打啥。
当我们使用fork的时候，也是先写入缓冲，再打印，缓冲也会被fork（
```

### 再谈程序设计：多任务、分布式系统与状态机
&emsp;如果你是计算机初学者，那么到此其实就可以结束了，接下来这部分内容将涉及Java Util Concurrent、Python多任务、分布式系统相关内容，和基础无缘，但是想挑战自己的也可以看一下。在文章的前几部分我们得知：***计算机硬件是状态机、固件是程序，但程序运行后的进程是状态机，操作系统是管理状态机的状态机。*** 由此我们发现，在计算机设计模型当中，状态机是一个对象的必不可少的概念。我们得知进程是系统状态机创建的一个子状态机，而在子状态机中，又可以fork出新的状态机。这个过程我们可以类比一下，不难发现这和多任务是相似的！在Java/Python中，存在的线程概念，我们需要知道的是<font color=#deb068> ***进程和线程本质上是对象不同，进程是相对于操作系统而言，是操作系统的子状态机，而线程是由进程创建，是进程的子状态机*** </font>：

<img src="/assets/img/StateMachine/ProcessAndThread.png" style="zoom:25%;display: block;
margin: 0 auto;" alt="Process And Thread" />

&emsp;所以我们对多任务编程又有了新的认识，我们发现了多任务实际上是状态机的 ***影分身***，而不仅仅只是停留在资源抢夺、数据不同步的认知上。<font color=#ff6164>***进程是操作系统的子状态机，进程又可以创建进程、线程、协程，它们的本质也都是状态机的创建***</font>

&emsp;我们再来看分布式当中的状态机，我们可以清晰地认识到，在分布式系统中多副本之间的数据同步，其实也是一种状态机，这种状态机和Linux下的fork很相似，因为分布式系统要求副本数据统一，也就是需要有相同的数据。这种严苛的要求同时出现在：节点故障检测、并发操作（CAP原则）、数据一致性和状态同步，你甚至能在分布式核心的共识算法当中看到状态机的身影！

&emsp;事实上，到此关于我的计算机相关知识基本上有了大致的总串，从这篇文章就可以看到，但是完了么？还没有！

## 最后，从离散数学的角度来看
&emsp;最开始，我告诉大家状态机的定义，其中我提到了 ***数学模型***，没错，是数学，计算机离散数学！如果可以，<font color=#ff6164>***状态机的所有状态都可以以数学的形式被准确描述***</font>，所以如果你的程序存在bug，那么严格意义上讲，我们可以做出一个单元测试的检查工具，用于检测程序所有意义上的状态。这些 ***状态最终会以树的形式展现*** 出来...对，没错，<font color=#ff6164>***从某种程度上讲我们可以使用数学图论表示状态机，使用深度遍历算法遍历每一个节点，实现代码检测***</font> ！也可以是Debug。以上就是整个篇文章的全部内容，终于我们可以得出这个观点：
<font color=#ee827c>

***“So, everything is a state machine. But state machines are mathematical objects. So everything is an object!”***
</font>

&emsp;[~~点我继续追番~~](./浅谈计算机当中的“进程”.md)

<div style="background:none;height: 5%;position: fixed;bottom: 0px;text-align: center;">
RobinElysia、叁玖、DLQC | Copyright © 2025 qwp Community | <a href="https://beian.miit.gov.cn/" target="_blank">辽ICP备2024040511号</a>
</div>
