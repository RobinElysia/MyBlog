---

title: 计算机当中的“进程”
description: 计算机进程内容详解
date: 2025-06-28
timeline: true
head:
  - - meta
    - name: keywords
      content: 计算机进程内容详解、进程、进程内存、资源描述符映射、操作系统对象
  - - meta
    - name: description
      content: 计算机进程内容详解
  - - meta
    - name: author
      content: RobinElysia
category:
  - RobinElysia
tag:
  - 操作系统设计原理

---

<link rel="stylesheet" href="/css/font-style.css">

# 计算机当中的“进程”
## 前言
&emsp;在[上一篇文档](./浅谈计算机设计哲学—“贯穿计算机硬件、操作系统与程序的万能状态机”.md)中，我们重点强调了<font class="strong">“Everything is a state machine.”</font>。这句话几乎抽象的描述了计算机整个设计的大体，但是我们不应该仅仅止步于此。所以我想在操作系统上~~大展拳脚~~，但总归操作系统的复杂程度不亚于航空母舰，能够将大型操作系统深入浅出，是一个极具挑战的任务...当然我们没有必要仔细到头发丝，能大体描述就能~~击败全国99%的玩家~~。<font class="gradient-title">所以我出手了，这篇文章我将深入浅出计算机操作系统的进程（初步）。</font>

## 上篇文章遗留：Zygote安卓世界里的受精卵进程

&emsp;“Zygote”，中文叫受精卵（~~真的就是生物那个词~~），是Android系统中一个非常核心的进程。在Android系统启动完成后，Zygote 会首先启动，并在系统运行期间常驻内存。它的职责简单粗暴却非常关键：**创建其他进程的模板。**

&emsp;你可以这么理解：Zygote 就像一个“克隆工厂”，每次你打开一个App，Zygote就 fork 出一个新的子进程，复制自己的进程上下文（代码段、数据段、堆、栈、寄存器……）并稍作修改。这样，启动速度比重新加载所有资源要快得多。**这种机制我们叫 Copy-on-Write <font class="strong">@Java</font>，节省了大量内存。**

&emsp;但是我们刚刚提到了 fork，我们得讲讲进程里到底“复制了什么？”

## fork后的进程：内存、寄存器和你看不见的世界

&emsp;当我们写下 `int* p = main(); printf("%p", p);` 时，很多人第一反应是：**咦？main还能返回指针？** 实际上，虽然 `main()` 是有定义规范的（返回 `int`），但我们更关心的是：**`p` 的地址指向哪一块内存？**

&emsp;这就进入了我们今天的主题：**进程的地址空间**。

&emsp;每一个进程都有一整块属于它自己的**虚拟地址空间**。在 Linux 上，可以在gdb调试使用 `info proc mappings` 或者 `cat /proc/$PID/maps`，就可以窥见一个进程的全貌。我们也可以写个 GDB 插件（~~AI来一个？~~）来自动将每个进程的映射信息输出成 Markdown 报表，非常适合做调试文档。

<img src="/assets/img/sysProcess/proc-maps.png" style="zoom:50%;display: block;
margin: 0 auto;" alt="maps" />

&emsp;当我们去查看这些信息时，可以看到在这些地址空间里，有些段很有趣，比如：
- `vvar`（只读）：保存系统调用相关的信息，这是干嘛的？AI一下
  - 哦，原来是防止进程频繁syscall的。比如 `gettimeofday()` 这样的函数可以不再陷入内核，而是从 `vvar` 区读取值
- `vdso`（可执行）：也是系统相关的辅助代码，性能优化神器

&emsp;我们发现，原来是这是一种系统优化。但是，这是该进程的内存，其他不在 `/proc/$PID/maps` 中的内存段？你敢访问试试，<font class="strong"> **Segmentation Fault** </font> 直接见面。所以，这里必须强调一个观点：**系统调用（syscall）并不总是切换到内核态！并且有些内存段是不可访问或者修改的！**

&emsp;但是话又说回来，在上个文章中我们仅仅简单说了进程的复制和复位，程序在Linux中到底是怎么复制然后初始化的？我们目前还是未知...

## execve之后：一个进程的原初状态

&emsp;当我们用 `execve()` 启动一个程序时，我们知道它其实不是“创建”，而是“重建”：它**替换**了当前进程的地址空间，重新加载二进制文件。这个过程仅涉及父子进程层面，不涉及操作系统层面（文件资源分配、各种ID和内核对象）

&emsp;这个加载过程由操作系统配合二进制格式（比如 ELF）完成，细节可参考 System V ABI：

- 把程序的 `.text` 段放入代码区域
- `.data` 和 `.bss` 放入数据段
- 加载器准备栈，并放置 `argc`, `argv`, `envp`
- 设置寄存器初始值，比如 `RIP` 指向程序入口地址 `_start` （main函数的底层）

&emsp;这一切都在瞬间完成，但每一次 App 启动、命令执行，都是一次 “进程重生”。

&emsp;进程在execve后会直接分配一段内存。但是，内存总有一天可能会被用光，这时候怎么办？

## 进程的房子不够大怎么办？内存扩展和mmap的魔法

&emsp;我们有必要先科普一下知识。首先，***现代操作系统为每个进程分配一块虚拟地址空间，在 32 位系统上通常是 4GB (0x00000000 - 0xFFFFFFFF)，而在 64 位下那就是银河级别的大小***，其次虚拟地址空间主要包括：

1. **代码段 (Text Segment)**：程序的机器码
2. **数据段 (Data Segment)**：初始化的全局变量
3. **BSS段**：未初始化的全局变量
4. **堆（Heap）**：动态分配，如 `malloc`（之后再说）
5. **栈（Stack）**：函数调用用的
6. **内存映射区域（Memory Mapped Region）**：文件、共享内存（这一部分重点关注）

&emsp;当你发现内存不够用时，可以使用 `mmap` 显式映射更多内存。它的参数结构如下：

```c
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```

&emsp;[man mmap](/file/mmap.txt)

```bash
# 手册命令
man mmap
```

- `addr`: 映射起始地址，NULL 为自动分配
- `length`: 映射长度
- `prot`: `PROT_READ`、`PROT_WRITE`、`PROT_EXEC` 权限划分
- `flags`: `MAP_SHARED` 或 `MAP_PRIVATE` 共享内存和私有内存
- `fd`: 要映射的文件描述符（`-1` 表示匿名内存）
- `offset`: 文件偏移，可以理解为一个文件的索引cur

&emsp;当我们看到这些参数时，诶，fd映射？好熟悉我好像在哪里见过？fd的存在可以实现把一个文件资源映射到内存中，不需要再open、raed… **那我是不是可以把整个磁盘，映射到内存空间里！** 好吧，答案是可以的，并且这个过程是惰性的。操作系统分配巨大的内存时运行非常快——是操作系统采用了“懒分配”机制，**只有访问才真正触发物理内存分配**，否则什么也不干（fast and slow path设计，这个之后的文章里也会讲）。

&emsp;但是问题又来了，假如这个时候我们的A进程在复制复位后得B，当B宕掉，A是怎么感知的？答案是子进程如果出现异常退出，CPU会捕获异常交给操作系统，操作系统发送信号通知父进程，~~你的儿子没了~~。

&emsp;还有一些题外话，Linux还提供了一些可以用来查看指定进程的任何地址 report memory map of a process（man pmap）：

```bash
pmap PID
# 就可以把一个进程的所有地址空间打印出来
```

&emsp;[man pmap](/file/pmap.txt)

&emsp;它是怎么实现的？其实是依赖 /proc 文件系统，可以 ls /proc/PID/ 查看，其中存在一个特殊的文件：ls /proc/PID/maps，打印出来：cat /proc/PID/maps，就是刚刚的pmap，只不过对其进行了删减（下文查看的是11进程）。我们也可以使用 strace 来检验

&emsp;[pmap 11](/file/pmapTest.txt)、[cat /proc/11/maps](/file/mapsTest.txt)

<img src="/assets/img/sysProcess/mapsAndpmap.png" style="zoom:50%;display: block;
margin: 0 auto;" alt="mapsAndpmap" />

&emsp;在程序中，我们还有 munmap（解除内存映射）、mprotect（修改内存区域的保护权限）这两个系统调用，我们可以使用man查看相关手册

```bash
man munmap
man mprotect
```

```C
void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
mprotect(ptr, 4096, PROT_READ); // 禁止写入

void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
munmap(ptr, 4096); // 释放内存
```
 
&emsp;之后我们会想，我们既然可以在程序内操作内存，那么我们是不是也可以在其他进程中操作进程内存？YES！

## 黑入别人的内存空间：进程劫持的魔法

接下来，聊聊更具“黑客气息”的部分：**我们能不能修改别的进程的内存？**

答案是：**当然可以，比如当年的物理修改器“金手指”**和**我们现在可能会用到的gdb调试**。

### Look-up Table(LUT)：金手指的灵魂

<img src="/assets/img/sysProcess/game-genie.webp" style="zoom:50%;display: block;
margin: 0 auto;" alt="game-genie" />

&emsp;早年间打游戏用的金手指，本质上就是在进程运行时修改内存值。它的大致原理很简单：

1. 游戏 ROM 加载到某个内存区域
2. 指针访问内存时，会从某地址返回一个值
3. 如果我们能劫持这个“返回值”，就能实现修改
4. 这就是 Lookup Table：中间插一层伪 ROM

&emsp;如果存在一个可以将返回值V1—变化为—V2的“中间件”（实际上也替换了卡带的固件，直接识别的是这个中间件），那么就可以实现物理意义上的数据修改。但问题是，有时候事与愿违，很多值（比如金币数量）可能是**动态地址**。怎么办？

<img src="/assets/img/sysProcess/knight.webp" style="zoom:50%;display: block;
margin: 0 auto;" alt="alterMem" />

那就用状态机思想，多次观察某个值的变化过程，从而“猜测”它的地址——这也是手机上**GG修改器**等修改游戏数据的原理（~~知识串联了有没有~~）。

### 入侵工具箱：你手上有这些武器

除了上述要给大家拓展的，实际上我们能做的还有很多，比如：

- `/proc/$PID/mem`: 可以直接读写某进程的内存（需要权限）
- 上文提到的gdb，它的`ptrace`: 调试神器，可以使用 `PTRACE_PEEKDATA` 和 `POKEDATA` 实现内存读写
- `process_vm_readv` 和 `process_vm_writev`: 高性能读写其他进程内存
- `pmap` + `cat /proc/$PID/maps`: 获取完整内存布局
- Windows？可以看看 [ReadProcessMemory](https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory) 和 [WriteProcessMemory](https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)，一样强大

## 拓展阅读与实战建议

1. 写一个 Python 脚本演示 mmap 的懒分配与缺页异常
2. 用 GDB 插件将 info registers + info proc mappings 输出为 Markdown 报表
3. 在虚拟机内尝试 `ptrace` 注入代码，修改运行中程序的行为
4. 看看 CIH 病毒的技术原理，理解固件篡改的真实危险
5. 学习如何使用 `/proc` 文件系统模拟调试器行为

<s>
<font class="gradient-title">
&emsp;当然我是知道各位不会实践的&emsp;
</font>
</s>

&emsp;[~~点我继续追番~~](./TheObjectOfTheOperatingSystem.md)