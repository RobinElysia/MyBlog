import{_ as r,c as d,h as t,b as n,i as s,e as a,w as o,j as p,a as c}from"./app-DFfsekp4.js";const m="/assets/img/sysProcess/proc-maps.png",u="/assets/img/sysProcess/mapsAndpmap.png",g="/assets/img/sysProcess/game-genie.webp",E="/assets/img/sysProcess/knight.webp",f={};function A(v,e){const i=p("RouteLink"),l=p("font");return c(),d("div",null,[e[23]||(e[23]=t('<link rel="stylesheet" href="/css/font-style.css"><h1 id="计算机当中的-进程" tabindex="-1"><a class="header-anchor" href="#计算机当中的-进程"><span>计算机当中的“进程”</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2>',3)),n("p",null,[e[3]||(e[3]=s(" 在")),a(i,{to:"/posts/OSDesign/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%9C%E8%B4%AF%E7%A9%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%87%E8%83%BD%E7%8A%B6%E6%80%81%E6%9C%BA%E2%80%9D.html"},{default:o(()=>e[0]||(e[0]=[s("上一篇文档")])),_:1,__:[0]}),e[4]||(e[4]=s("中，我们重点强调了")),a(l,{class:"strong"},{default:o(()=>e[1]||(e[1]=[s("“Everything is a state machine.”")])),_:1,__:[1]}),e[5]||(e[5]=s("。这句话几乎抽象的描述了计算机整个设计的大体，但是我们不应该仅仅止步于此。所以我想在操作系统上")),e[6]||(e[6]=n("s",null,"大展拳脚",-1)),e[7]||(e[7]=s("，但总归操作系统的复杂程度不亚于航空母舰，能够将大型操作系统深入浅出，是一个极具挑战的任务...当然我们没有必要仔细到头发丝，能大体描述就能")),e[8]||(e[8]=n("s",null,"击败全国99%的玩家",-1)),e[9]||(e[9]=s("。")),a(l,{class:"gradient-title"},{default:o(()=>e[2]||(e[2]=[s("所以我出手了，这篇文章我将深入浅出计算机操作系统的进程（初步）。")])),_:1,__:[2]})]),e[24]||(e[24]=n("h2",{id:"上篇文章遗留-zygote安卓世界里的受精卵进程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#上篇文章遗留-zygote安卓世界里的受精卵进程"},[n("span",null,"上篇文章遗留：Zygote安卓世界里的受精卵进程")])],-1)),e[25]||(e[25]=n("p",null,[s(" “Zygote”，中文叫受精卵（"),n("s",null,"真的就是生物那个词"),s("），是Android系统中一个非常核心的进程。在Android系统启动完成后，Zygote 会首先启动，并在系统运行期间常驻内存。它的职责简单粗暴却非常关键："),n("strong",null,"创建其他进程的模板。")],-1)),n("p",null,[e[13]||(e[13]=s(" 你可以这么理解：Zygote 就像一个“克隆工厂”，每次你打开一个App，Zygote就 fork 出一个新的子进程，复制自己的进程上下文（代码段、数据段、堆、栈、寄存器……）并稍作修改。这样，启动速度比重新加载所有资源要快得多。")),n("strong",null,[e[11]||(e[11]=s("这种机制我们叫 Copy-on-Write ")),a(l,{class:"strong"},{default:o(()=>e[10]||(e[10]=[s("@Java")])),_:1,__:[10]}),e[12]||(e[12]=s("，节省了大量内存。"))])]),e[26]||(e[26]=t('<p> 但是我们刚刚提到了 fork，我们得讲讲进程里到底“复制了什么？”</p><h2 id="fork后的进程-内存、寄存器和你看不见的世界" tabindex="-1"><a class="header-anchor" href="#fork后的进程-内存、寄存器和你看不见的世界"><span>fork后的进程：内存、寄存器和你看不见的世界</span></a></h2><p> 当我们写下 <code>int* p = main(); printf(&quot;%p&quot;, p);</code> 时，很多人第一反应是：<strong>咦？main还能返回指针？</strong> 实际上，虽然 <code>main()</code> 是有定义规范的（返回 <code>int</code>），但我们更关心的是：<strong><code>p</code> 的地址指向哪一块内存？</strong></p><p> 这就进入了我们今天的主题：<strong>进程的地址空间</strong>。</p><p> 每一个进程都有一整块属于它自己的<strong>虚拟地址空间</strong>。在 Linux 上，可以在gdb调试使用 <code>info proc mappings</code> 或者 <code>cat /proc/$PID/maps</code>，就可以窥见一个进程的全貌。我们也可以写个 GDB 插件（<s>AI来一个？</s>）来自动将每个进程的映射信息输出成 Markdown 报表，非常适合做调试文档。</p><p><img src="'+m+'" style="zoom:50%;display:block;margin:0 auto;" alt="maps"></p><p> 当我们去查看这些信息时，可以看到在这些地址空间里，有些段很有趣，比如：</p><ul><li><code>vvar</code>（只读）：保存系统调用相关的信息，这是干嘛的？AI一下 <ul><li>哦，原来是防止进程频繁syscall的。比如 <code>gettimeofday()</code> 这样的函数可以不再陷入内核，而是从 <code>vvar</code> 区读取值</li></ul></li><li><code>vdso</code>（可执行）：也是系统相关的辅助代码，性能优化神器</li></ul>',8)),n("p",null,[e[15]||(e[15]=s(" 我们发现，原来是这是一种系统优化。但是，这是该进程的内存，其他不在 ")),e[16]||(e[16]=n("code",null,"/proc/$PID/maps",-1)),e[17]||(e[17]=s(" 中的内存段？你敢访问试试，")),a(l,{class:"strong"},{default:o(()=>e[14]||(e[14]=[n("strong",null,"Segmentation Fault",-1)])),_:1,__:[14]}),e[18]||(e[18]=s(" 直接见面。所以，这里必须强调一个观点：")),e[19]||(e[19]=n("strong",null,"系统调用（syscall）并不总是切换到内核态！并且有些内存段是不可访问或者修改的！",-1))]),e[27]||(e[27]=t(`<p> 但是话又说回来，在上个文章中我们仅仅简单说了进程的复制和复位，程序在Linux中到底是怎么复制然后初始化的？我们目前还是未知...</p><h2 id="execve之后-一个进程的原初状态" tabindex="-1"><a class="header-anchor" href="#execve之后-一个进程的原初状态"><span>execve之后：一个进程的原初状态</span></a></h2><p> 当我们用 <code>execve()</code> 启动一个程序时，我们知道它其实不是“创建”，而是“重建”：它<strong>替换</strong>了当前进程的地址空间，重新加载二进制文件。这个过程仅涉及父子进程层面，不涉及操作系统层面（文件资源分配、各种ID和内核对象）</p><p> 这个加载过程由操作系统配合二进制格式（比如 ELF）完成，细节可参考 System V ABI：</p><ul><li>把程序的 <code>.text</code> 段放入代码区域</li><li><code>.data</code> 和 <code>.bss</code> 放入数据段</li><li>加载器准备栈，并放置 <code>argc</code>, <code>argv</code>, <code>envp</code></li><li>设置寄存器初始值，比如 <code>RIP</code> 指向程序入口地址 <code>_start</code> （main函数的底层）</li></ul><p> 这一切都在瞬间完成，但每一次 App 启动、命令执行，都是一次 “进程重生”。</p><p> 进程在execve后会直接分配一段内存。但是，内存总有一天可能会被用光，这时候怎么办？</p><h2 id="进程的房子不够大怎么办-内存扩展和mmap的魔法" tabindex="-1"><a class="header-anchor" href="#进程的房子不够大怎么办-内存扩展和mmap的魔法"><span>进程的房子不够大怎么办？内存扩展和mmap的魔法</span></a></h2><p> 我们有必要先科普一下知识。首先，<em><strong>现代操作系统为每个进程分配一块虚拟地址空间，在 32 位系统上通常是 4GB (0x00000000 - 0xFFFFFFFF)，而在 64 位下那就是银河级别的大小</strong></em>，其次虚拟地址空间主要包括：</p><ol><li><strong>代码段 (Text Segment)</strong>：程序的机器码</li><li><strong>数据段 (Data Segment)</strong>：初始化的全局变量</li><li><strong>BSS段</strong>：未初始化的全局变量</li><li><strong>堆（Heap）</strong>：动态分配，如 <code>malloc</code>（之后再说）</li><li><strong>栈（Stack）</strong>：函数调用用的</li><li><strong>内存映射区域（Memory Mapped Region）</strong>：文件、共享内存（这一部分重点关注）</li></ol><p> 当你发现内存不够用时，可以使用 <code>mmap</code> 显式映射更多内存。它的参数结构如下：</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c"><pre><code><span class="line"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p> <a href="/file/mmap.txt">man mmap</a></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token comment"># 手册命令</span></span>
<span class="line"><span class="token function">man</span> mmap</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>addr</code>: 映射起始地址，NULL 为自动分配</li><li><code>length</code>: 映射长度</li><li><code>prot</code>: <code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code> 权限划分</li><li><code>flags</code>: <code>MAP_SHARED</code> 或 <code>MAP_PRIVATE</code> 共享内存和私有内存</li><li><code>fd</code>: 要映射的文件描述符（<code>-1</code> 表示匿名内存）</li><li><code>offset</code>: 文件偏移，可以理解为一个文件的索引cur</li></ul><p> 当我们看到这些参数时，诶，fd映射？好熟悉我好像在哪里见过？fd的存在可以实现把一个文件资源映射到内存中，不需要再open、raed… <strong>那我是不是可以把整个磁盘，映射到内存空间里！</strong> 好吧，答案是可以的，并且这个过程是惰性的。操作系统分配巨大的内存时运行非常快——是操作系统采用了“懒分配”机制，<strong>只有访问才真正触发物理内存分配</strong>，否则什么也不干（fast and slow path设计，这个之后的文章里也会讲）。</p><p> 但是问题又来了，假如这个时候我们的A进程在复制复位后得B，当B宕掉，A是怎么感知的？答案是子进程如果出现异常退出，CPU会捕获异常交给操作系统，操作系统发送信号通知父进程，<s>你的儿子没了</s>。</p><p> 还有一些题外话，Linux还提供了一些可以用来查看指定进程的任何地址 report memory map of a process（man pmap）：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">pmap PID</span>
<span class="line"><span class="token comment"># 就可以把一个进程的所有地址空间打印出来</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p> <a href="/file/pmap.txt">man pmap</a></p><p> 它是怎么实现的？其实是依赖 /proc 文件系统，可以 ls /proc/PID/ 查看，其中存在一个特殊的文件：ls /proc/PID/maps，打印出来：cat /proc/PID/maps，就是刚刚的pmap，只不过对其进行了删减（下文查看的是11进程）。我们也可以使用 strace 来检验</p><p> <a href="/file/pmapTest.txt">pmap 11</a>、<a href="/file/mapsTest.txt">cat /proc/11/maps</a></p><p><img src="`+u+`" style="zoom:50%;display:block;margin:0 auto;" alt="mapsAndpmap"></p><p> 在程序中，我们还有 munmap（解除内存映射）、mprotect（修改内存区域的保护权限）这两个系统调用，我们可以使用man查看相关手册</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">man</span> munmap</span>
<span class="line"><span class="token function">man</span> mprotect</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C"><pre><code><span class="line">void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span>
<span class="line">mprotect(ptr, 4096, PROT_READ); // 禁止写入</span>
<span class="line"></span>
<span class="line">void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span>
<span class="line">munmap(ptr, 4096); // 释放内存</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p> 之后我们会想，我们既然可以在程序内操作内存，那么我们是不是也可以在其他进程中操作进程内存？YES！</p><h2 id="黑入别人的内存空间-进程劫持的魔法" tabindex="-1"><a class="header-anchor" href="#黑入别人的内存空间-进程劫持的魔法"><span>黑入别人的内存空间：进程劫持的魔法</span></a></h2><p>接下来，聊聊更具“黑客气息”的部分：<strong>我们能不能修改别的进程的内存？</strong></p><p>答案是：<strong>当然可以，比如当年的物理修改器“金手指”<strong>和</strong>我们现在可能会用到的gdb调试</strong>。</p><h3 id="look-up-table-lut-金手指的灵魂" tabindex="-1"><a class="header-anchor" href="#look-up-table-lut-金手指的灵魂"><span>Look-up Table(LUT)：金手指的灵魂</span></a></h3><p><img src="`+g+'" style="zoom:50%;display:block;margin:0 auto;" alt="game-genie"></p><p> 早年间打游戏用的金手指，本质上就是在进程运行时修改内存值。它的大致原理很简单：</p><ol><li>游戏 ROM 加载到某个内存区域</li><li>指针访问内存时，会从某地址返回一个值</li><li>如果我们能劫持这个“返回值”，就能实现修改</li><li>这就是 Lookup Table：中间插一层伪 ROM</li></ol><p> 如果存在一个可以将返回值V1—变化为—V2的“中间件”（实际上也替换了卡带的固件，直接识别的是这个中间件），那么就可以实现物理意义上的数据修改。但问题是，有时候事与愿违，很多值（比如金币数量）可能是<strong>动态地址</strong>。怎么办？</p><p><img src="'+E+'" style="zoom:50%;display:block;margin:0 auto;" alt="alterMem"></p><p>那就用状态机思想，多次观察某个值的变化过程，从而“猜测”它的地址——这也是手机上<strong>GG修改器</strong>等修改游戏数据的原理（<s>知识串联了有没有</s>）。</p><h3 id="入侵工具箱-你手上有这些武器" tabindex="-1"><a class="header-anchor" href="#入侵工具箱-你手上有这些武器"><span>入侵工具箱：你手上有这些武器</span></a></h3><p>除了上述要给大家拓展的，实际上我们能做的还有很多，比如：</p><ul><li><code>/proc/$PID/mem</code>: 可以直接读写某进程的内存（需要权限）</li><li>上文提到的gdb，它的<code>ptrace</code>: 调试神器，可以使用 <code>PTRACE_PEEKDATA</code> 和 <code>POKEDATA</code> 实现内存读写</li><li><code>process_vm_readv</code> 和 <code>process_vm_writev</code>: 高性能读写其他进程内存</li><li><code>pmap</code> + <code>cat /proc/$PID/maps</code>: 获取完整内存布局</li><li>Windows？可以看看 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory" target="_blank" rel="noopener noreferrer">ReadProcessMemory</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory" target="_blank" rel="noopener noreferrer">WriteProcessMemory</a>，一样强大</li></ul><h2 id="拓展阅读与实战建议" tabindex="-1"><a class="header-anchor" href="#拓展阅读与实战建议"><span>拓展阅读与实战建议</span></a></h2><ol><li>写一个 Python 脚本演示 mmap 的懒分配与缺页异常</li><li>用 GDB 插件将 info registers + info proc mappings 输出为 Markdown 报表</li><li>在虚拟机内尝试 <code>ptrace</code> 注入代码，修改运行中程序的行为</li><li>看看 CIH 病毒的技术原理，理解固件篡改的真实危险</li><li>学习如何使用 <code>/proc</code> 文件系统模拟调试器行为</li></ol>',42)),n("s",null,[a(l,{class:"gradient-title"},{default:o(()=>e[20]||(e[20]=[s("  当然我是知道各位不会实践的  ")])),_:1,__:[20]})]),n("p",null,[e[22]||(e[22]=s(" ")),a(i,{to:"/posts/OSDesign/TheObjectOfTheOperatingSystem.html"},{default:o(()=>e[21]||(e[21]=[n("s",null,"点我继续追番",-1)])),_:1,__:[21]})])])}const k=r(f,[["render",A]]),b=JSON.parse('{"path":"/posts/OSDesign/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BD%93%E4%B8%AD%E7%9A%84%E2%80%9C%E8%BF%9B%E7%A8%8B%E2%80%9D.html","title":"计算机当中的“进程”","lang":"en-US","frontmatter":{"title":"计算机当中的“进程”","description":"计算机进程内容详解","date":"2025-06-28T00:00:00.000Z","timeline":true,"head":[["meta",{"name":"keywords","content":"计算机进程内容详解、进程、进程内存、资源描述符映射、操作系统对象"}],["meta",{"name":"description","content":"计算机进程内容详解"}],["meta",{"name":"author","content":"RobinElysia"}]],"category":["RobinElysia"],"tag":["操作系统设计原理"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"上篇文章遗留：Zygote安卓世界里的受精卵进程","slug":"上篇文章遗留-zygote安卓世界里的受精卵进程","link":"#上篇文章遗留-zygote安卓世界里的受精卵进程","children":[]},{"level":2,"title":"fork后的进程：内存、寄存器和你看不见的世界","slug":"fork后的进程-内存、寄存器和你看不见的世界","link":"#fork后的进程-内存、寄存器和你看不见的世界","children":[]},{"level":2,"title":"execve之后：一个进程的原初状态","slug":"execve之后-一个进程的原初状态","link":"#execve之后-一个进程的原初状态","children":[]},{"level":2,"title":"进程的房子不够大怎么办？内存扩展和mmap的魔法","slug":"进程的房子不够大怎么办-内存扩展和mmap的魔法","link":"#进程的房子不够大怎么办-内存扩展和mmap的魔法","children":[]},{"level":2,"title":"黑入别人的内存空间：进程劫持的魔法","slug":"黑入别人的内存空间-进程劫持的魔法","link":"#黑入别人的内存空间-进程劫持的魔法","children":[{"level":3,"title":"Look-up Table(LUT)：金手指的灵魂","slug":"look-up-table-lut-金手指的灵魂","link":"#look-up-table-lut-金手指的灵魂","children":[]},{"level":3,"title":"入侵工具箱：你手上有这些武器","slug":"入侵工具箱-你手上有这些武器","link":"#入侵工具箱-你手上有这些武器","children":[]}]},{"level":2,"title":"拓展阅读与实战建议","slug":"拓展阅读与实战建议","link":"#拓展阅读与实战建议","children":[]}],"git":{"updatedTime":1762519389000,"contributors":[{"name":"qwp_p","username":"","email":"qwp20060309@outlook.com","commits":2}],"changelog":[{"hash":"cfd09171d1be97fa09ef8c4fc2be80d788219c63","time":1762519389000,"email":"qwp20060309@outlook.com","author":"qwp_p","message":"Update blog content and add new articles"},{"hash":"4c644f83f2c04e7b866c269634041fbc3addef9f","time":1755331266000,"email":"qwp20060309@outlook.com","author":"qwp_p","message":"博客更改"}]},"filePathRelative":"posts/OSDesign/浅谈计算机当中的“进程”.md","excerpt":"<link rel=\\"stylesheet\\" href=\\"/css/font-style.css\\">\\n<h1>计算机当中的“进程”</h1>\\n<h2>前言</h2>\\n<p> 在<a href=\\"/posts/OSDesign/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%9C%E8%B4%AF%E7%A9%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%87%E8%83%BD%E7%8A%B6%E6%80%81%E6%9C%BA%E2%80%9D.html\\" target=\\"_blank\\">上一篇文档</a>中，我们重点强调了。这句话几乎抽象的描述了计算机整个设计的大体，但是我们不应该仅仅止步于此。所以我想在操作系统上<s>大展拳脚</s>，但总归操作系统的复杂程度不亚于航空母舰，能够将大型操作系统深入浅出，是一个极具挑战的任务...当然我们没有必要仔细到头发丝，能大体描述就能<s>击败全国99%的玩家</s>。</p>"}');export{k as comp,b as data};
