import{_ as p}from"./hardAndSystemAndDB-CcuhjfCO.js";import{_ as u,c as d,h as a,b as n,e as t,i as l,w as r,j as o,a as E}from"./app-BPzQcCmO.js";const g="/assets/img/slowComputer/ER.png",m="/assets/img/slowComputer/layout.png",f={};function b(h,e){const i=o("RouteLink"),s=o("font");return E(),d("div",null,[e[21]||(e[21]=a('<link rel="stylesheet" href="/css/font-style.css"><h1 id="一个真正的数据库入门-权威-指南-下" tabindex="-1"><a class="header-anchor" href="#一个真正的数据库入门-权威-指南-下"><span>一个真正的数据库入门“权威”指南（下）</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2>',3)),n("p",null,[e[1]||(e[1]=l(" OK，上一篇文章我们简单的指明了数据持久化的发展历程，从最开始的穿孔纸带到磁盘和SSD。我们了解了什么数据库是怎么来的？于是我们引入了操作系统和文件系统。事实上，文件系统属于操作系统设计原理——虚拟化范畴，这里因为侧重点不同我们没办法详细展开介绍，所以我打算挖坑（")),t(i,{to:"/posts/TechnicalTalk/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BD%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"},{default:r(()=>e[0]||(e[0]=[l("浅谈操作系统当中的文件系统")])),_:1,__:[0]}),e[2]||(e[2]=l("）"))]),e[22]||(e[22]=a('<p><img src="'+p+'" style="zoom:20%;display:block;margin:0 auto;" alt="maps"></p><p> 但是话又说回来，我们知道的这些仅仅知识表面，数据库到底是怎么实现的？数据库的原理是什么？性能如何？怎么存数据的...这些我们一概不知道......</p><h3 id="我们常用的数据库" tabindex="-1"><a class="header-anchor" href="#我们常用的数据库"><span>我们常用的数据库</span></a></h3><p> 世界上数据库千千万，但在学习开发的路上，<strong>MySQL</strong> 和 <strong>Redis</strong> 是两座必经大山。MySQL 是典型的关系型数据库，Redis 是典型的非关系型（键值存储）。前者像正经的饭店——菜单、菜品、账单一应俱全；后者像是家门口的小卖铺——方便、快捷、但是种类少。</p><p>其他数据库？可以学，但更多时候是路过，留个影就行。我们今天就不“广撒网”了。</p><h3 id="数据库的-e-r-图" tabindex="-1"><a class="header-anchor" href="#数据库的-e-r-图"><span>数据库的 E-R 图</span></a></h3>',6)),n("p",null,[e[4]||(e[4]=l(" 最开始，")),t(s,{class:"strong"},{default:r(()=>e[3]||(e[3]=[l("我们想描述事物与事物、数据与数据之间的关系，去画出我们对数据的构思，这个时候我们就需要E-R图。")])),_:1,__:[3]})]),e[23]||(e[23]=a('<p> E-R 图，全称 <strong>Entity–Relationship 图</strong>，中文翻译为<strong>实体–联系图</strong>。别害怕，它其实就是帮你把数据世界画出来的一种方式。矩形代表“人和事物”（实体），椭圆代表“属性”，菱形代表“关系”。</p><p>举个栗子：</p><ul><li>实体：学生（矩形）</li><li>属性：学号、姓名、年龄（椭圆）</li><li>关系：选修（菱形）——学生和课程连在一起</li></ul><p><img src="'+g+'" style="zoom:20%;display:block;margin:0 auto;" alt="maps"></p><p> 画完图，你就能直观地看到数据是怎么联系在一起的。说白了，E-R 图就是数据库的“手绘地图”，让你在进入复杂的 SQL 城市之前，先搞清楚道路是怎么连的，这对于数据库设计而言是必要的。不要听信什么UML、ER图已死，不需要学，这些都是开发们极端言论，即便我们现在不再关注形式上的画图，但是很大程度上会在脑子里构思。</p><p> 当我们描述完我们的“蓝图”之后，我们就可以该来构建这些数据了，也就是我们的SQL语言...</p><h3 id="数据库的语言" tabindex="-1"><a class="header-anchor" href="#数据库的语言"><span>数据库的语言</span></a></h3><p> 我们想要开始了解数据库，就需要先从它的语言开始。我们的关系型数据库在发明的时候，就有一个共识是我们需要一门统一的标准，这个标准语言可以定义、操作数据库，让开发作者不再困于繁琐的数据修改中。这就是SQL语言它的作用。</p>',8)),n("p",null,[e[6]||(e[6]=l(" SQL本身是一种操作数据库的语言，但它把几个子模块拆散，就像一个团队里人负责不同的工作。最常见的四大类是：DDL、DML、DCL和TCL。")),t(s,{class:"strong"},{default:r(()=>e[5]||(e[5]=[l("DDL（Data Definition Language，数据定义语言）专门用于定义数据库的结构，比如建表、改表、删表。它的回答是命令“数据库长什么样”。常见有CREATE、ALTER、DROP。理解可以为，在搭建一个仓库时决定一个仓库有多少间房、每间房里放什么样的架构子；DML（Data Manipulation Language，数据操作语言）负责数据的“搬进搬出”，比如插入、修改、删除、查询。常见命令有INSERT、UPDATE、DELETE、SELECT。这就比你往仓库里搬货、调整货物位置、清理旧货，或者查找某个货物；DCL（Data Control Language，数据控制语言）用来管权限和安全，比如给用户授权或者恢复权限。一般命令有GRANT、REVOKE。它就像仓库里的门禁系统，谁能进、能动什么东西，都是由DCL来管的；TCL（Transaction Control Language，事务控制语言）书写控制事务的，比如提交、回滚、设置保存点。常见的命令有COMMIT、、ROLLBACK。SAVEPOINT这相当于仓库的“账本系统”，可以保证单个操作或全算数，或全作废。")])),_:1,__:[5]})]),e[24]||(e[24]=n("p",null," 在了解完SQL语言有哪些部分后，这些SQL语句是怎么处理和执行的，它的过程实际上是一个谜，所以我们还需要进一步，去看看数据库是怎么被我们操作的，它到底经历了那些过程...",-1)),e[25]||(e[25]=n("h3",{id:"数据库的组成结构与内部实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#数据库的组成结构与内部实现"},[n("span",null,"数据库的组成结构与内部实现")])],-1)),e[26]||(e[26]=n("p",null," 很多人觉得数据库就是个“大 Excel”，实际上，它的复杂程度可比 Excel 复杂多了。以 MySQL 为例，它的内部可以大概拆成以下几个部分：",-1)),t(s,{class:"strongGreen"},{default:r(()=>e[7]||(e[7]=[n("ol",null,[n("li",null,[n("p",null,[n("strong",null,"连接层"),n("br"),l(" 就像餐馆的迎宾，负责处理客户端的连接、权限认证。")])]),n("li",null,[n("p",null,[n("strong",null,"SQL 层"),n("br"),l(" 这里是“前厅服务员”，解析你写的 SQL语句，检查有没有语法问题，然后生成执行计划。")])]),n("li",null,[n("p",null,[n("strong",null,"存储引擎层"),n("br"),l(" 真正的“后厨”。MySQL 最常用的是 InnoDB，它负责数据的存储、索引、事务处理。你点的菜（数据），就是在这里被端上来的。与文件系统相互联系，调用文件系统相关的接口。")])]),n("li",null,[n("p",null,[n("strong",null,"底层文件系统"),n("br"),l(" 最终，所有数据都要落到磁盘文件里。数据库会把表切成页、区、段，精细到字节的管理。")])])],-1)])),_:1,__:[7]}),n("p",null,[e[9]||(e[9]=l(" 也就是说，当我们写好一个SQL语句的时候，")),t(s,{class:"strong"},{default:r(()=>e[8]||(e[8]=[l("它首先会通过连接层将语句传输到数据库内部，数据库内部的第一个大门是SQL解析层，也就是我们的SQL语句处理层，他会对SQL语句进行解析，翻译成数据库执行引擎可以执行的语句，然后解析过后的数据会进一步发送到在存储管理层，这是数据库的第二个大门，这一层涉及与文件系统交互、保障数据成功写入磁盘等功能，于是SQL数据就被成功的执行并落入底层文件系统层，并成功落盘。")])),_:1,__:[8]})]),e[27]||(e[27]=n("p",null,[n("img",{src:m,style:{zoom:"40%",display:"block",margin:"0 auto"},alt:"maps"})],-1)),e[28]||(e[28]=n("p",null," 而 Redis 就轻量很多，它没有像MySQL那样把数据写入磁盘，而是直接把数据放内存里（就像随手放在桌面上的小零食）。当然，为了掉电不丢数据，它也提供了 RDB 和 AOF 两种持久化机制（这两个持久化作为了解吧）。",-1)),e[29]||(e[29]=n("p",null," 当然，我们应该清楚的知道数据库为了保障数据所做的各种牺牲，也就是在存储管理层，我们的数据库干了什么。那么我们就需要来了解另一个东西了，那就是ACID与事务。",-1)),e[30]||(e[30]=n("h3",{id:"数据库的-acid-与事务",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#数据库的-acid-与事务"},[n("span",null,"数据库的 ACID 与事务")])],-1)),e[31]||(e[31]=n("p",null,[l(" 数据库界有个“四字箴言”："),n("strong",null,"ACID"),l("。这个四字神简称保障了是你的数据库数据安全，")],-1)),t(s,{class:"strongGreen"},{default:r(()=>e[10]||(e[10]=[n("ol",null,[n("li",null,[n("p",null,[n("strong",null,"A - 原子性（Atomicity）"),n("br"),l(" “要么全做，要么全不做”。它就像转账一样，你要给朋友转 100 块，这事儿分两步：扣你 100，给他加 100。原子性保证这两步要么都成功，要么都失败，不可能扣了你的钱却没到他账户里。要么一起成功，要么一起失败，没有“半拉子工程”。")])]),n("li",null,[n("p",null,[n("strong",null,"C - 一致性（Consistency）"),n("br"),l(" 数据库从一个“合法状态”转到另一个“合法状态”。就是数据库里的规则不能被破坏。比如你和朋友总共有 1000 块，不管怎么转，总和都得是 1000。如果结果跑出来 900 或 1100，那就是数据库在瞎搞。换句话说，一致性保证数据在事务前后都处于一种“靠谱”的状态。")])]),n("li",null,[n("p",null,[n("strong",null,"I - 隔离性（Isolation）"),n("br"),l(" 多个人同时在数据库里捣鼓，也不能互相干扰。就像两个人同时抢火车票，数据库得保证结果和一个人一个人依次买一样，绝不能出现“同一张票两个人都买到了”的鬼事。虽然背后可能有各种锁和控制机制，但对我们来说，它确保了并发操作互不干扰。")])]),n("li",null,[n("p",null,[n("strong",null,"D - 持久性（Durability）"),n("br"),l(" 一旦提交，数据就是铁打的。掉电、宕机，也得靠日志和刷盘把数据救回来。就是“一旦办完就板上钉钉”。比如转账成功后，就算银行服务器立刻宕机或者掉电，数据也不会丢。因为数据库会把这些变化写到日志里，等恢复时还能“补账”，确保你已经提交的事务不会凭空消失。")])])],-1)])),_:1,__:[10]}),n("p",null,[e[12]||(e[12]=l(" 这四字真言是所有事务性数据库的根本，需要保障数据的安全。那么事务是什么？它就像数据库里的“合同”，保证你说的事，要么做到位，要么不动刀。")),t(s,{class:"strong"},{default:r(()=>e[11]||(e[11]=[l("比如说我们上边提到的转账例子：假设你要给朋友转 100 块，原子性保证这事儿要么扣你 100 并成功加到朋友账户，要么干脆失败回滚，绝不会出现钱从你账户扣了却没到账；同时，别人在你转账过程中也在操作账户，隔离性确保他看到的余额不是“半扣半没扣”的中间状态，就像你们俩的操作被排好队一样，互不干扰；最后，当转账成功提交后，就算系统马上断电了，持久性也能保证这笔转账记录不会丢，钱一定稳稳地在你朋友账户里。")])),_:1,__:[11]})]),n("p",null,[e[14]||(e[14]=l(" 事实上，当我们保障了AID之后，C就自动保障了。可以说")),t(s,{class:"underline-gradient"},{default:r(()=>e[13]||(e[13]=[l("AID是因，C数据一致性是果")])),_:1,__:[13]})]),n("p",null,[e[16]||(e[16]=l(" ")),t(s,{class:"strong"},{default:r(()=>e[15]||(e[15]=[l("一般非关系型（Redis）数据库没有事务，它们更偏向于性能，或者是想象成“笔记本”，没有关系的结构化需求，你想记啥就记啥，很随意。")])),_:1,__:[15]})]),e[32]||(e[32]=a('<p> 当然数据安全这部分内容实际上可以单独写一篇博客，因为它实在是太重要了。</p><h3 id="数据库范式" tabindex="-1"><a class="header-anchor" href="#数据库范式"><span>数据库范式</span></a></h3><h4 id="范式" tabindex="-1"><a class="header-anchor" href="#范式"><span>范式</span></a></h4><p> 数据库设计里还有个“范式”的概念。范式的目的就是——“别让数据库太乱太冗余”。</p><blockquote><p><strong>第一范式（1NF）</strong>：每个字段都是原子的，别搞一列塞好几个手机号。即“每个字段必须是不可再分”<br><strong>第二范式（2NF）</strong>：不能出现部分依赖。即“表中所有非主键需要完全依赖主键”<br><strong>第三范式（3NF）</strong>：非主键字段不能传来传去依赖别的非主键。即“非主键数据之间不可有联系和重复”</p></blockquote><p> 比如我们有一个“学生选课表”，如果把学生姓名、学号、课程名、任课老师、老师电话都塞在同一行里，就会出现很多冗余：同一个学生选了多门课，他的姓名和学号会重复存；同一个老师教了多门课，他的电话也会重复。按照 第三范式（3NF） 的要求，我们可以把它拆成三张表：学生表（存学生信息）、课程表（存课程和老师信息）、选课表（存学生和课程的对应关系）。这样既避免了数据冗余，也能保证如果老师换了电话，只需要更新一处，不会出现“有的课更新了，有的没更新”的情况。</p><p> 说白了，范式是为了整洁。但凡事有度：<strong>范式化</strong> 让你结构清晰，但查询可能变慢；<em>反范式化</em> 能加快查询，但可能数据冗余。到底怎么选？——实践出真知，视业务而定。</p><h4 id="反范式" tabindex="-1"><a class="header-anchor" href="#反范式"><span>反范式</span></a></h4>',8)),n("p",null,[e[19]||(e[19]=l(" 但是，有时候我们需要再性能与范式之间做取舍取舍。这就是数据库设计里一个经典的矛盾：")),t(s,{class:"strong"},{default:r(()=>e[17]||(e[17]=[l("性能 vs 范式")])),_:1,__:[17]}),e[20]||(e[20]=l("。")),t(s,{class:"underline-gradient"},{default:r(()=>e[18]||(e[18]=[l("范式化带来结构清晰和一致性，但查询复杂度增加；而反范式化（有意引入冗余，比如缓存计算好的字段）能减少 join，提高性能，却增加了维护复杂度。因此在工程实践中，我们往往会在“读多写少”的场景下选择更高的范式，在“读写频繁、追求速度”的场景下进行适度的反范式化。")])),_:1,__:[18]})]),e[33]||(e[33]=a('<h2 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后"><span>写在最后</span></a></h2><p> 数据库这个东西，表面看似“黑盒”，其实里面有着一整套复杂的机制。MySQL 给了我们安全可靠的存储，Redis 给了我们快速灵活的访问。学数据库，就像拆一辆车：先学会开，再拆发动机，最后你甚至能自己造一辆。</p><h2 id="拓展" tabindex="-1"><a class="header-anchor" href="#拓展"><span>拓展</span></a></h2><p> 没有什么是手搓一个理解不了的，如果有，那就再搓一个。如果你想深入了解数据库实现，那么请观看<a href="https://www.learncs.site/docs/curriculum-resource/15-445" target="_blank" rel="noopener noreferrer">卡耐基梅隆CMU大学的CS课程</a>，老师会手把手带你使用C++手搓一个数据库，<a href="http://www.cs.emory.edu/~cheung/Courses/377/Syllabus/syl.html" target="_blank" rel="noopener noreferrer">详细的相关笔记（推荐研读）</a>。当然你也可以参考这本书<a href="https://github.com/apachecn/huazhang-cs-books/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E5%8E%9F%E4%B9%A6%E7%AC%AC6%E7%89%88.pdf" target="_blank" rel="noopener noreferrer">数据库系统概念原书第6版</a>，这本书详细的描述了数据库的基础。另一本书<a href="https://book.douban.com/subject/35078474/" target="_blank" rel="noopener noreferrer">数据库系统的内幕</a>则是深入数据库设计原理，你看完这本书后，数据库就已经对你没有任何威胁了。</p><h2 id="preference" tabindex="-1"><a class="header-anchor" href="#preference"><span>Preference</span></a></h2><p>[1] <a href="https://jyywiki.cn/OS/2025/lect21.md" target="_blank" rel="noopener noreferrer">蒋炎岩——存储设备原理</a></p><p>[3] <a href="https://anamma.com.br/en/persistence-vs-perseverance/" target="_blank" rel="noopener noreferrer">What is the Difference Between Persistence and Perseverance?</a></p><p>[4] <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C/02%20%20SQL%20vs%20NoSQL%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%E4%BA%94%E8%8A%B1%E5%85%AB%E9%97%A8%E7%9A%84%E2%80%9CSQL%E2%80%9D.md" target="_blank" rel="noopener noreferrer">SQL vs NoSQL：一次搞清楚五花八门的“SQL”</a></p><p>[5] <a href="https://www.bilibili.com/video/BV1aF411u7Ct" target="_blank" rel="noopener noreferrer">硬件茶谈——【硬核科普】固态硬盘的缓存是干什么的？有缓存和无缓存有什么区别？</a></p>',9))])}const L=u(f,[["render",b]]),S=JSON.parse('{"path":"/posts/TechnicalTalk/TowATrulySimpleIntroductionToDatabases.html","title":"真正的数据库入门“权威”指南（下）","lang":"en-US","frontmatter":{"title":"真正的数据库入门“权威”指南（下）","description":"一个真正的数据库入门“权威”指南","date":"2025-09-08T00:00:00.000Z","timeline":true,"head":[["meta",{"name":"keywords","content":"一个真正的数据库入门“权威”指南"}],["meta",{"name":"description","content":"一个真正的数据库入门“权威”指南"}],["meta",{"name":"author","content":"RobinElysia"}]],"category":["RobinElysia"],"tag":["技术漫谈"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[{"level":3,"title":"我们常用的数据库","slug":"我们常用的数据库","link":"#我们常用的数据库","children":[]},{"level":3,"title":"数据库的 E-R 图","slug":"数据库的-e-r-图","link":"#数据库的-e-r-图","children":[]},{"level":3,"title":"数据库的语言","slug":"数据库的语言","link":"#数据库的语言","children":[]},{"level":3,"title":"数据库的组成结构与内部实现","slug":"数据库的组成结构与内部实现","link":"#数据库的组成结构与内部实现","children":[]},{"level":3,"title":"数据库的 ACID 与事务","slug":"数据库的-acid-与事务","link":"#数据库的-acid-与事务","children":[]},{"level":3,"title":"数据库范式","slug":"数据库范式","link":"#数据库范式","children":[]}]},{"level":2,"title":"写在最后","slug":"写在最后","link":"#写在最后","children":[]},{"level":2,"title":"拓展","slug":"拓展","link":"#拓展","children":[]},{"level":2,"title":"Preference","slug":"preference","link":"#preference","children":[]}],"git":{"updatedTime":1762519389000,"contributors":[{"name":"qwp_p","username":"","email":"qwp20060309@outlook.com","commits":1}],"changelog":[{"hash":"cfd09171d1be97fa09ef8c4fc2be80d788219c63","time":1762519389000,"email":"qwp20060309@outlook.com","author":"qwp_p","message":"Update blog content and add new articles"}]},"filePathRelative":"posts/TechnicalTalk/TowATrulySimpleIntroductionToDatabases.md","excerpt":"<link rel=\\"stylesheet\\" href=\\"/css/font-style.css\\">\\n<h1>一个真正的数据库入门“权威”指南（下）</h1>\\n<h2>前言</h2>\\n<p> OK，上一篇文章我们简单的指明了数据持久化的发展历程，从最开始的穿孔纸带到磁盘和SSD。我们了解了什么数据库是怎么来的？于是我们引入了操作系统和文件系统。事实上，文件系统属于操作系统设计原理——虚拟化范畴，这里因为侧重点不同我们没办法详细展开介绍，所以我打算挖坑（<a href=\\"/posts/TechnicalTalk/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BD%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html\\" target=\\"_blank\\">浅谈操作系统当中的文件系统</a>）</p>"}');export{L as comp,S as data};
